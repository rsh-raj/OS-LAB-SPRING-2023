#include <bits/stdc++.h>
#include <pthread.h>
using namespace std;

// declarations
const int first_node_id = 0, last_node_id = 37700, max_queue_size = 10340;
const int k = 10;
enum Action
{
    post,
    comment,
    like
};
typedef struct Action_
{
    int user_id;
    int action_id;
    Action action_type;
    time_t timestamp;
    Action_(int user_id, int action_id, Action action_type) // constructor for action class
    {
        this->user_id = user_id;
        this->action_id = action_id;
        this->action_type = action_type;
        time(&timestamp); // timestamp is set to current time
    }
    Action_(){};
} action;

typedef struct node_
{
    vector<action> wall_queue;
    vector<action> feed_queue;
    int priority;
    vector<int> neighbors;
    int action_id[3], feed_queue_in = 0, feed_queue_out = 0, feed_queue_read_in = 0, feed_queue_read_out = 0;
    pthread_mutex_t feed_queue_push_update_mutex, feed_queue_read_post_mutex;
    node_(int neighbour_id) // constructor to assign random priority to a node
    {
        this->priority = rand() % 2;
        this->neighbors.push_back(neighbour_id);
        int i;
        for (i = post; i <= like; i++)
            action_id[i] = 0;
        pthread_mutex_init(&this->feed_queue_push_update_mutex, NULL);
        pthread_mutex_init(&this->feed_queue_read_post_mutex, NULL);
        this->feed_queue.resize(max_queue_size);
    }
    node_(){}; // default constructor

} node;

unordered_map<int, node> graph;
vector<action> userS_pushU_shared_queue(max_queue_size); //
unordered_set<int> active_node;                          // will contain the node which have unread feed queue
int shared_queue_in = 0, shared_queue_out = 0;

// Mutex and condition variables
pthread_mutex_t shared_queue_push_update_mutex, active_node_mutex;
pthread_cond_t cond_shared_queue_push_update, cond_feed_queue;
// thread processes
int rand_helper(int &poolSize, int unused_pool[])
{
    int idx = rand() % (poolSize + 1);
    int val = unused_pool[idx];
    swap(unused_pool[idx], unused_pool[poolSize]);
    poolSize--;
    return val;
}
void *userSimulator(void *param)
{
    vector<int> selected_nodes(100);
    int itr = 1;
    fstream fp;
    fp.open("user_simulator.log");
    while (1)
    {
        int poolSize = last_node_id;
        int unused_pool[last_node_id + 1];
        for (int i = 0; i < poolSize; i++)
            unused_pool[i] = i;
        for (int i = 0; i < 100; i++)
        {
            selected_nodes[i] = rand_helper(poolSize, unused_pool);
        }
        int num = 0;
        bool flag = true;
        // cout << "Following actions have been generated in itr" << itr << endl;
        for (auto node_id : selected_nodes)
        {
            node curr_node = graph[node_id];
            int num_actions = k * (1 + log2(curr_node.neighbors.size()));
            for (int i = 0; i < num_actions; i++)
            {
                int action_type = rand() % 3;
                action rand_action = action(node_id, curr_node.action_id[action_type]++, (Action)action_type);
                graph[node_id].wall_queue.push_back(rand_action);
                // pthread_mutex_lock(&shared_queue_push_update_mutex);
                while (((shared_queue_in + 1) % max_queue_size) == shared_queue_out)
                {
                    cout << "BUFFER FULL" << endl;
                    break;
                }; // buffer full wait
                userS_pushU_shared_queue[shared_queue_in] = rand_action;
                shared_queue_in = (shared_queue_in + 1) % max_queue_size;
                pthread_cond_broadcast(&cond_shared_queue_push_update);
                num++;

                // put this in a lock
                cout << "action_id:   " << rand_action.action_id << "     type:     " << rand_action.action_type << "     user_id:       " << rand_action.user_id << "        timestamp:      " << rand_action.timestamp << endl;
                fp << "action_id:   " << rand_action.action_id << "     type:     " << rand_action.action_type << "     user_id:       " << rand_action.user_id << "        timestamp:      " << rand_action.timestamp << endl;
            }
            // if (flag)
            //     cout << "SELECTED LIST OF NODES IN ITERATION " << itr << " ALONG WITH THEIR NUMBER OF ACTIONS AND DEGREE ARE FOLLOWING\n", flag = false; // also write to log file
            // cout << node_id << "        " << num_actions << "        " << curr_node.neighbors.size();                                                    // also write to log file
            // cout << '\n';
        }
        cout << "Total action generated by me: " << num << '\n';
        fp << "Total action generated by me: " << num << '\n';

        cout << "I went to sleep";
        sleep(120 * 100);
        itr++;
    }
}
int total_action_handled = 0;
int total_pushed = 0;
pthread_mutex_t temp;
void *pushUpdate(void *param)
{
    fstream fout;
    fout.open("push_update.log");

    // try
    // {
    while (1)
    {
        pthread_mutex_lock(&shared_queue_push_update_mutex);
        while (shared_queue_in == shared_queue_out) // wait as queue is empty;
        {
            if (pthread_cond_wait(&cond_shared_queue_push_update, &shared_queue_push_update_mutex) > 0)
            {
                // cout<<"Waiting "
            }
        }
        action curr_action = userS_pushU_shared_queue[shared_queue_out];
        shared_queue_out = (shared_queue_out + 1) % max_queue_size;
        pthread_mutex_unlock(&shared_queue_push_update_mutex);

        // add a lock here
        cout << "action with following details have been successfully handled by push_update     " << curr_action.user_id << "       " << curr_action.action_id << endl;
        fout << "action with following details have been successfully handled by push_update     " << curr_action.user_id << "       " << curr_action.action_id << endl;
        // remove the lock here


        pthread_mutex_lock(&temp);
        total_action_handled++;
        cout << total_action_handled << endl;
        pthread_mutex_unlock(&temp);

        for (auto neighbour_id : graph[curr_action.user_id].neighbors)
        {   
            
            // apply a lock here also broadcast to all readPost thread(maybe pass the id of then node which feed have been updated)
            // graph[neighbour_id].feed_queue.push(curr_action);
            // release the lock
            node curr_node = graph[neighbour_id];
            while (((curr_node.feed_queue_in + 1) % max_queue_size) == curr_node.feed_queue_out)
            {
                cout << "BUFFER FULL FOR SHARED QUEUE!!!" << endl;
            }
            pthread_mutex_lock(&curr_node.feed_queue_push_update_mutex);
            curr_node.feed_queue[curr_node.feed_queue_in] = curr_action;
            curr_node.feed_queue_in = (curr_node.feed_queue_in + 1) % max_queue_size;
            pthread_mutex_unlock(&curr_node.feed_queue_push_update_mutex);

            pthread_mutex_lock(&active_node_mutex);
            active_node.insert(neighbour_id);
            pthread_mutex_unlock(&active_node_mutex);
            pthread_cond_signal(&cond_feed_queue);
        }
    }
}
void *readPost(void *param)
{
    while (1)
    {
        int node_id = 0;
        pthread_mutex_lock(&active_node_mutex);
        while (active_node.size() == 0)
        {
            pthread_cond_wait(&cond_feed_queue, &active_node_mutex);
        }
        node_id = *active_node.begin();
        active_node.erase(node_id);
        pthread_mutex_unlock(&active_node_mutex);


        pthread_mutex_lock(&graph[node_id].feed_queue_read_post_mutex);
        while (graph[node_id].feed_queue_read_out = graph[node_id].feed_queue_read_in)
        {
            action curr_action = graph[node_id].feed_queue[graph[node_id].feed_queue_read_out];
            // cout << "I read action number: " << curr_action.action_id<<" Of type: "<<curr_action.action_type<<" By user_id"<<curr_action.user_id<<" time"<<curr_action.timestamp<<endl;
            graph[node_id].feed_queue_read_out = (graph[node_id].feed_queue_read_out + 1) % max_queue_size;
        }
        pthread_mutex_unlock(&graph[node_id].feed_queue_read_post_mutex);
    }

    // to be implemented
}
int main()
{
    // Main thread and loading of graph from file
    srand(time(NULL));
    ifstream fin;
    fin.open("musae_git_edges.csv");
    int line = 0;
    while (fin && ++line)
    {
        string s;
        getline(fin, s);
        if (line == 1 || s == "")
            continue;
        size_t pos = s.find(',');
        if (pos == string::npos)
        {
            cout << "Wrong format for line: " << line << "string: " << s << endl;
            continue;
        }
        try
        {
            int node1_id = stoi(s.substr(0, pos)), node2_id = stoi(s.substr(pos + 1, s.length() - pos));
            if (graph.find(node1_id) == graph.end())
                graph[node1_id] = node(node2_id);
            else
                graph[node1_id].neighbors.push_back(node2_id);
            if (graph.find(node2_id) == graph.end())
                graph[node2_id] = node(node1_id);
            else
                graph[node2_id].neighbors.push_back(node1_id);
        }
        catch (const std::exception &e)
        {
            cout << "Some error in parsing line: " << line << "string: " << s << endl;
            std::cerr << e.what() << '\n';
        }
    }
    pthread_mutex_init(&shared_queue_push_update_mutex, NULL);
    pthread_mutex_init(&active_node_mutex, NULL);
    pthread_mutex_init(&temp, NULL);
    pthread_cond_init(&cond_shared_queue_push_update, NULL);
    pthread_cond_init(&cond_feed_queue, NULL);
    // user_simulator thread
    pthread_t user_simulator;
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_create(&user_simulator, &attr, userSimulator, NULL);
    pthread_t push_update[10];
    for (int i = 0; i < 10; i++)
    {
        pthread_create(&push_update[i], NULL, pushUpdate, NULL);
    }
    pthread_t read_post[25];
    for (int i = 0; i < 25; i++)
    {
        pthread_create(&read_post[i], NULL, readPost, NULL);
    }

    // joining the various threads after completion
    pthread_join(user_simulator, NULL);
    for (int i = 0; i < 25; i++)
    {
        pthread_join(push_update[i], NULL);
    }
    cout << "ans: " << total_action_handled << endl;
    for (int i = 0; i < 10; i++)
    {
        pthread_join(read_post[i], NULL);
    }

    return 0;
}